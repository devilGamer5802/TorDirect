// Official WebTorrent Service Worker
// Based on https://github.com/webtorrent/webtorrent/blob/master/sw.min.js

let aborted = false;

self.addEventListener('install', () => {
  self.skipWaiting();
});

self.addEventListener('fetch', event => {
  const response = handleFetch(event);
  if (response) {
    event.respondWith(response);
  }
});

self.addEventListener('activate', () => {
  self.clients.claim();
});

function handleFetch(event) {
  const { url } = event.request;
  
  if (!url.includes(self.registration.scope + 'webtorrent/')) {
    return null;
  }
  
  if (url.includes(self.registration.scope + 'webtorrent/keepalive/')) {
    return new Response();
  }
  
  if (url.includes(self.registration.scope + 'webtorrent/cancel/')) {
    return new Response(new ReadableStream({
      cancel() {
        aborted = true;
      }
    }));
  }
  
  return handleStreamRequest(event);
}

async function handleStreamRequest({ request }) {
  const { url, method, headers, destination } = request;
  
  const clients_list = await clients.matchAll({ 
    type: 'window', 
    includeUncontrolled: true 
  });
  
  const [response, port] = await new Promise(resolve => {
    for (const client of clients_list) {
      const channel = new MessageChannel();
      const { port1, port2 } = channel;
      
      port1.onmessage = ({ data }) => {
        resolve([data, port1]);
      };
      
      client.postMessage({
        url,
        method,
        headers: Object.fromEntries(headers.entries()),
        scope: self.registration.scope,
        destination,
        type: 'webtorrent'
      }, [port2]);
    }
  });
  
  let timeout = null;
  
  const cleanup = () => {
    port.postMessage(false);
    clearTimeout(timeout);
    port.onmessage = null;
  };
  
  if (response.body !== 'STREAM') {
    cleanup();
    return new Response(response.body, response);
  }
  
  return new Response(new ReadableStream({
    pull(controller) {
      return new Promise(resolve => {
        port.onmessage = ({ data }) => {
          if (data) {
            controller.enqueue(data);
          } else {
            cleanup();
            controller.close();
          }
          resolve();
        };
        
        if (!aborted) {
          clearTimeout(timeout);
          if (destination !== 'document') {
            timeout = setTimeout(() => {
              cleanup();
              resolve();
            }, 5000);
          }
          port.postMessage(true);
        }
      });
    },
    
    cancel() {
      cleanup();
    }
  }), response);
};
